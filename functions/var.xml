<?xml version="1.0" encoding="iso-8859-2"?>
<!-- $Revision: 1.3 $ -->
 <reference id="ref.variables">
  <title>Variabile</title>
  <titleabbrev>Variabile</titleabbrev>

  <partintro>
   <para>
    Pentru informaþii despre comportamentul variabilelor, consultaþi capitolul
    <link linkend="language.variables">Variabile</link>, secþiunea
    <link linkend="langref">Documentaþia limbajului</link> din manual.
   </para>
  </partintro>

  <refentry id="function.doubleval">
   <refnamediv>
    <refname>doubleval</refname>
    <refpurpose>Alias pentru <function>floatval</function></refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
    <para>
     Aceastã funcþie este un alias pentru funcþia <function>floatval</function>.
    </para>
    <note>
     <para>
      Acest alias este inutil acum, în urma redenumirii unei funcþii, dar în
      versiunile mai vechi ale PHP veþi fi nevoiþi sã folosiþi acest alias, întrucât
      <function>floatval</function> nu existã în acele versiuni.
     </para>
    </note>
   </refsect1>
  </refentry>

  <refentry id="function.empty">
   <refnamediv>
    <refname>empty</refname>
    <refpurpose>Determinã dacã o variabilã este definitã</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>boolean</type><methodname>empty</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <note>
     <para>
      <function>empty</function> este o construcþie de limbaj.
     </para>
    </note>
    <para>
     Este inversul folosirii construcþiei 
     <literal>(boolean) <parameter>var</parameter></literal>,
     cu deosebirea cã nu se genereazã mesaj de atenþionare dacã
     variabila nu este definitã. Consultaþi
     <link linkend="language.types.boolean.casting">conversia la
     boolean</link> pentru detalii.
    </para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = 0;

if (empty($var)) {  // este evaluatã ca TRUE
    echo '$var este 0 sau nu este definitã';
}

if (!isset($var)) { // este evaluatã ca FALSE
    echo '$var nu este definitã';
}
?>]]>
      </programlisting>
     </informalexample>

    <simpara>
     De notat cã este lipsitã de sens folosirea cu un parametru care
     nu reprezintã o variabilã. De exemplu,
     <command>empty (addslashes ($name))</command> nu are sens.
     In acest exemplu este verificat ceva ce nu reprezintã o variabilã
     cã ar avea valoarea &false;.
    </simpara>
    <simpara>
     Mai consultaþi <function>isset</function> ºi
     <function>unset</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.floatval">
   <refnamediv>
    <refname>floatval</refname>
    <refpurpose>Returneazã valoarea de tip float a unei variabile</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>float</type><methodname>floatval</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Returneazã valoarea de tip <type>float</type> a parametrului <parameter>var</parameter>.
    </simpara>
    <para>
     <parameter>var</parameter> poate sã fie orice tip scalar. Nu se poate folosi
     <function>floatval</function> pe tablouri (<type>array</type>)
     sau obiecte (<type>object</type>).
    <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = '122.34343Gigi';
$float_value_of_var = floatval ($var);
print $float_value_of_var; // afiºeazã 122.34343
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Mai consultaþi <function>intval</function>,
     <function>strval</function>, <function>settype</function> ºi
     <link linkend="language.types.type-juggling">Tipuri
     de date</link>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.gettype">
   <refnamediv>
    <refname>gettype</refname>
    <refpurpose>Returneazã tipul unei variabile</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>string</type><methodname>gettype</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     Returneazã tipul variabilei PHP <parameter>var</parameter>.
    </para>
    <warning>
     <simpara>
      Nu folosiþi niciodatã <function>gettype</function> pentru a testa
      un anumit tip de datã pentru cã ºirul de caractere returnat poate sã
      se schimbe la versiuni urmãtoare. În plus, operaþia este ºi consumatoare
      de timp, deoarece implicã comparaþie între ºiruri de caractere.
     </simpara>
     <simpara>
      Se recomandã folosirea funcþiilor <literal>is_*</literal>.
     </simpara>
    </warning>
    <para>
     Valori posibile pentru ºirul de caractere returnat sunt:
     <itemizedlist>
      <listitem>
       <simpara>"<type>boolean</type>" (începând cu PHP 4)</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>integer</type>"</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>double</type>" (din motive istorice, se returneazã
       "double" în loc de "float" în cazul tipului <type>float</type>)
       </simpara>
      </listitem>
      <listitem>
       <simpara>"<type>string</type>"</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>array</type>"</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>object</type>"</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>resource</type>" (începând cu PHP 4)</simpara>
      </listitem>
      <listitem>
       <simpara>"<type>NULL</type>" (începând cu PHP 4)</simpara>
      </listitem>
      <listitem>
       <simpara>"user function" (doar în PHP 3, nu se mai foloseºte)</simpara>
      </listitem>
      <listitem>
       <simpara>"unknown type"<!-- someone's joking? --></simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Pentru PHP 4, se foloseºte <function>function_exists</function> ºi
     <function>method_exists</function> în loc de
     <function>gettype</function> pentru o funcþie.
    </para>
    <para>
     Mai cunsultaþi
     <function>settype</function>,
     <function>is_array</function>,
     <function>is_bool</function>,
     <function>is_float</function>,
     <function>is_integer</function>,
     <function>is_null</function>,
     <function>is_numeric</function>,
     <function>is_object</function>,
     <function>is_resource</function>,
     <function>is_scalar</function> ºi
     <function>is_string</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.get-defined-vars">
   <refnamediv>
    <refname>get_defined_vars</refname>
    <refpurpose>
     Returneazã un tablou cu toate variabilele definite
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>array</type><methodname>get_defined_vars</methodname>
      <void/>
     </methodsynopsis>
    <para>
     Aceastã funcþie returneazã un tablou multidimensional care conþine
     toate variabilele definite (globale, definite de utilizator sau
     de cãtre server).
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$b = array(1, 1, 2, 3, 5, 8);

$arr = get_defined_vars();

// afiºeazã $b
print_r($arr["b"]);

// afiºeazã calea cãtre interpretorul PHP (dacã este folosit ca CGI)
// exemplu: /usr/local/bin/php
echo $arr["_"];

// afiºeazã parametrii liniei de comandã, dacã existã
print_r($arr["argv"]);

// afiºeazã toate variabilele server
print_r($arr["HTTP_SERVER_VARS"]);

// afiºeazã toate cheile tablourilor disponibile
print_r(array_keys(get_defined_vars()));
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Mai consultaþi <function>get_defined_functions</function> ºi
     <function>get_defined_constants</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.get-resource-type">
   <refnamediv>
    <refname>get_resource_type</refname>
    <refpurpose>
     Returneazã tipul resursei
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>string</type><methodname>get_resource_type</methodname>
      <methodparam><type>resource</type><parameter>handle</parameter></methodparam>
     </methodsynopsis>
    <para>
     Aceastã funcþie returneazã un ºir de caractere care reprezintã tipul
     resursei <type>resource</type> care i-a fost pasatã. Dacã parametrul
     <type>resource</type> nu este o resursã validã, se va genera o eroare.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$c = mysql_connect();
echo get_resource_type($c) . "\n";
// afiºeazã: mysql link

$fp = fopen("foo", "w");
echo get_resource_type($fp) . "\n";
// afiºeazã: file

$doc = new_xmldoc("1.0");
echo get_resource_type($doc->doc) . "\n";
// afiºeazã: domxml document
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.import-request-variables">
   <refnamediv>
    <refname>import_request_variables</refname>
    <refpurpose>Importã variabilele GET/POST/Cookie variabile globale</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>import_request_variables</methodname>
      <methodparam><type>string</type><parameter>types</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>prefix</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Importsã variabilele de tip GET/POST/Cookie, fãcându-le vizibile ca variabile
     globale. Este util dacã se dezactiveazã
     <link linkend="ini.register-globals">register_globals</link>,
     dar se doreºte totuºi vizibilitatea unor variabile in mod global.
    </simpara>
    <simpara>
     Folosind parametrul <parameter>types</parameter>
     se poate specifica ce variabile sã fie importate. Se pot folosi caracterele
     'G', 'P' ºi 'C' pentru variabile GET, POST, respectiv Cookie.
     Aceste caractere nu sunt cu majuscule nesemnificative, adicã
     se poate folosi ºi o combinaþie a caracterelor 'g', 'p' ºi 'c'.
     POST include ºi informaþiile despre fiºiere încãrcate.
     De notat cã ordinea în care sunt scrie caracterele este importantã.
     Dacã se foloseºte combinaþia "gp", variabilele POST vor suprascrie
     variabilele GET cu aceleaºi nume. Orice litere în afarã de GPC sunt
     ignorate.
    </simpara>
    <note>
     <para>
      Deºi parametrul <parameter>prefix</parameter> este opþional,
      se va genera o atenþionare la nivelul utilizatorului dacã acesta lipseºte
      sau este un ºir de caractere vid. Acest lucru se face din motive de
      securitate. Dacã se foloseºte nivelul implicit de raportare a erorilor,
      atenþionãrile la nivelul utilizatorului nu sunt afiºate.
     </para>
    </note>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// vor fi importate variabilele GET ºi POST
// cu prefixul "rvar_"
import_request_variables("gP", "rvar_");
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     Mai consultaþi <link linkend="ini.register-globals">register_globals</link>
     ºi <link linkend="ini.track-vars">track_vars</link>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.intval">
   <refnamediv>
    <refname>intval</refname>
    <refpurpose>Returneazã valoarea întreagã a unei variabile</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>int</type><methodname>intval</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><type>int</type><parameter>base</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Returneazã valoarea întreagã a variabilei <parameter>var</parameter>,
     folosind baza specificatã în <parameter>base</parameter> pentru conversie
     (implicit se foloseºte baza 10).
    </simpara>
    <simpara>
     <parameter>var</parameter> poate sã fie orice tip scalar. Nu se poate folosi
     <function>intval</function> pentru tablouri (<type>array</type>) sau
     obiecte (<type>object</type>).
    </simpara>
    <note>
     <para>
      Parametrul <parameter>base</parameter> are efect pentru
      <function>intval</function> doar dacã parametrul
      <parameter>var</parameter> este un ºir de caractere.
     </para>
    </note>
    <simpara>
     Mai consultaþi <function>floatval</function>,
     <function>strval</function>, <function>settype</function> ºi
     <link linkend="language.types.type-juggling">Tipuri
     de date</link>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.is-array">
   <refnamediv>
    <refname>is_array</refname>
    <refpurpose>Decide dacã o variabilã este un tablou</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_array</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     Returneazã &true; dacã <parameter>var</parameter> este de tip <type>array</type>,
     &false; în caz contrar.
    </para>
    <para>
     Mai consultaþi 
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_integer</function>,
     <function>is_string</function>, ºi
     <function>is_object</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-bool">
   <refnamediv>
    <refname>is_bool</refname>
     <refpurpose>
      Decide dacã o variabilã este de tip boolean
     </refpurpose>
    </refnamediv>
    <refsect1>
     <title>Descriere</title>
     <methodsynopsis>
       <type>bool</type><methodname>is_bool</methodname>
       <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
     <para>
      Returneazã &true; dacã <parameter>var</parameter> este de tip
      <type>boolean</type>, &false; în caz contrar.
     </para>
     <para>
     Mai consultaþi 
     <function>is_array</function>,
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_integer</function>,
     <function>is_string</function>, ºi
     <function>is_object</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-double">
   <refnamediv>
    <refname>is_double</refname>
    <refpurpose>Alias pentru <function>is_float</function></refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
    <para>
     Aceastã funcþie este un alias pentru funcþia <function>is_float</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-float">
   <refnamediv>
    <refname>is_float</refname>
    <refpurpose>Decide dacã o variabilã este de tip float</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_float</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <simpara>
      Returneazã &true; dacã <parameter>var</parameter> este de tip
      <type>float</type>, &false; în caz contrar.
    </simpara>
    <note>
     <para>
      Pentru a testa dacã o variabilã este numericã sau un ºir de caractere
      care reprezintã un numãr (cum ar fi variabilele venite prin intermediul
      unui form, care au întotdeauna de tip <type>string</type>),  trebuie
      folositã funcþia <function>is_numeric</function>.
     </para>
    </note>
    <simpara>
     Mai consultaþi 
     <function>is_bool</function>,
     <function>is_int</function>,
     <function>is_integer</function>,
     <function>is_numeric</function>,
     <function>is_string</function>,
     <function>is_array</function> ºi
     <function>is_object</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.is-int">
   <refnamediv>
    <refname>is_int</refname>
    <refpurpose>Decide dacã o variabilã este de tip integer</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_int</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <simpara>
      Returneazã &true; dacã <parameter>var</parameter> este de tip
      <type>integer</type>, &false; în caz contrar.
    </simpara>
    <note>
     <para>
      Pentru a testa dacã o variabilã este numericã sau un ºir de caractere
      care reprezintã un numãr (cum ar fi variabilele venite prin intermediul
      unui form, care au întotdeauna de tip <type>string</type>),  trebuie
      folositã funcþia <function>is_numeric</function>.
     </para>
    </note>
    <simpara>
     Mai consultaþi <function>is_bool</function>,
     <function>is_float</function>,
     <function>is_integer</function>,
     <function>is_numeric</function>,
     <function>is_string</function>,
     <function>is_array</function>, ºi
     <function>is_object</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.is-integer">
   <refnamediv>
    <refname>is_integer</refname>
    <refpurpose>Alias pentru <function>is_int</function></refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
    <para>
     Aceastã funcþie este un alias pentru <function>is_int</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-long">
   <refnamediv>
    <refname>is_long</refname>
    <refpurpose>Alias pentru <function>is_int</function></refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
    <para>
     Aceastã funcþie este un alias pentru <function>is_int</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-null">
   <refnamediv>
    <refname>is_null</refname>
    <refpurpose>
     Decide dacã o variabilã este &null;
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_null</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
      Returneazã &true; dacã <parameter>var</parameter> este
      <type>null</type>, &false; în caz contrar.
    </para>
    <para>
     Mai consultaþi <function>is_bool</function>,
     <function>is_numeric</function>,
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_string</function>,
     <function>is_object</function>,
     <function>is_array</function>,
     <function>is_integer</function> ºi
     <function>is_real</function>.
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.is-numeric">
   <refnamediv>
    <refname>is_numeric</refname>
    <refpurpose>
     Decide dacã o variabilã este numericã sau un ºir de caractere numeric
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_numeric</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
      Returneazã &true; dacã <parameter>var</parameter> este numericã
      sau un ºir de caractere numeric, &false; în caz contrar.
    </para>
    <para>
     Mai consultaþi <function>is_bool</function>,
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_string</function>,
     <function>is_object</function>,
     <function>is_array</function>, ºi
     <function>is_integer</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-object">
   <refnamediv>
    <refname>is_object</refname>
    <refpurpose>Decide dacã o variabilã este de tip object</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_object</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     Returneazã &true; dacã <parameter>var</parameter> este de tip <type>object</type>,
     &false; în caz contrar.
    </para>
    <para>
     Mai consultaþi <function>is_bool</function>,
     <function>is_int</function>,
     <function>is_integer</function>,
     <function>is_float</function>,
     <function>is_string</function>, ºi
     <function>is_array</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-real">
   <refnamediv>
    <refname>is_real</refname>
    <refpurpose>Alias pentru <function>is_float</function></refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
    <para>
     Aceastã funcþie este un alias pentru <function>is_float</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-resource">
   <refnamediv>
    <refname>is_resource</refname>
    <refpurpose>
     Decide dacã o variabilã este o resursã
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_resource</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>is_resource</function> returneazã &true; dacã
     <parameter>var</parameter> este o resursã, &false; în caz contrar.
    </para>
    <para>
     Consultaþi documentaþia pentru tipul <type>resource</type> pentru detalii.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-scalar">
   <refnamediv>
    <refname>is_scalar</refname>
    <refpurpose>
     Decide dacã o variabilã este un scalar
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_scalar</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     <function>is_scalar</function> returneazã &true; dacã
     <parameter>var</parameter> este un scalar, &false; în caz contrar.
    </para>
    <para>
     Variabilele de tip scalar includ tipurile <type>integer</type>, 
     <type>float</type>, <type>string</type> ºi <type>boolean</type>.  
     Tipurile <type>array</type>, <type>object</type> ºi <type>resource</type> 
     nu sunt tipuri scalare.
     <informalexample>
      <programlisting role="php">
<!-- TODO: better example, this one can be quite misleading for unexperienced
           programmers.  -->
<![CDATA[
<?php
function show_var($var) {
    if (is_scalar($var)) {
        echo $var;
    } else {
        var_dump($var);
    }
}
$pi = 3.1416;
$proteins = array("hemoglobin", "cytochrome c oxidase", "ferredoxin");

show_var($pi);
// afiºeazã 3.1416

show_var($proteins);
// afiºeazã:
// array(3) {
//   [0]=>
//   string(10) "hemoglobin"
//   [1]=>
//   string(20) "cytochrome c oxidase"
//   [2]=>
//   string(10) "ferredoxin"
// }
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      <function>is_scalar</function> nu considerã tipul <type>resource</type>
      ca fiind scalar, resursele fiind tipuri de date abstracte care sunt bazate
      pe valori întregi. Acest detaliu de implementare se poate modifica pe viitor,
      aºa cã nu trebuie sã scrieþi aplicaþii care sã depindã de el.
     </para>
    </note>
    <para>
     Mai consultaþi <function>is_bool</function>,
     <function>is_numeric</function>,
     <function>is_float</function>,
     <function>is_int</function>,
     <function>is_real</function>,
     <function>is_string</function>,
     <function>is_object</function>,
     <function>is_array</function> ºi
     <function>is_integer</function>.
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.is-string">
   <refnamediv>
    <refname>is_string</refname>
    <refpurpose>Decide dacã o variabilã este de tip string</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_string</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <para>
     Returneazã &true; dacã <parameter>var</parameter> este de tip
     <type>string</type>, &false; în caz contrar.
    </para>
    <para>
     Mai consultaþi <function>is_bool</function>,
     <function>is_int</function>,
     <function>is_integer</function>,
     <function>is_float</function>,
     <function>is_real</function>,
     <function>is_object</function>, ºi
     <function>is_array</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.isset">
   <refnamediv>
    <refname>isset</refname>
    <refpurpose>Determinã dacã o variabilã este definitã</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>boolean</type><methodname>isset</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><parameter>...</parameter></methodparam>
     </methodsynopsis>
    <note> 
       <para> 
        <function>isset</function> este o construcþie de limbaj. 
       </para> 
      </note> 
    <simpara>
     Returneazã &true; dacã <parameter>var</parameter>
     existsã, &false; în caz contrar.
    </simpara>
    <para>
     Dacã o variabilã a fost ºtearsã cu <function>unset</function>,
     <function>isset</function> va returna &false;. De asemenea,
     <function>isset</function> va returna &false; dacã se testeazã o variabilã
     a cãrei valoare a fost setatã ca &null;. De notat cã octetul nul
     (<literal>"\0"</literal>) nu este echivalent cu constanta PHP &null;.
     <informalexample>
      <programlisting role="php">
<![CDATA[
$a = "test";
$b = "alt_test";

echo isset ($a); // TRUE
echo isset ($a, $b) //TRUE

unset ($a);
echo isset ($a); // FALSE
echo isset ($a, $b); //FALSE

$foo = NULL;
print isset ($foo); // FALSE
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Mai consultaþi <function>empty</function> ºi
     <function>unset</function>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.print-r">
   <refnamediv>
    <refname>print_r</refname>
    <refpurpose>
     Afiºeazã informaþii despre o variabilã într-un format uºor de înþeles
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>void</type><methodname>print_r</methodname>
      <methodparam><type>mixed</type><parameter>expression</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     <function>print_r</function> afiºeazã informaþii espre o variabilã
     într-un format uºor de citit de cãtre utilizatori. Dacã se paseazã
     un parametru de tip <type>string</type>, <type>integer</type> sau
     <type>float</type>, va fi afiºatã chiar valoarea parametrului.
     Dacã se paseazã un parametru de tip <type>array</type>,
     valorile vor fi prezentate într-o formã care aratã cheile ºi valorile.
     Asemãnãtor se întâmplã ºi cu tipul <type>object</type>.
    </simpara>
    <simpara>
     De reþinut cã <function>print_r</function> va muta pointer-ul tabloului
     la sfârºit. Trebuie folositã funcþia <function>reset</function> pentru
     a aduce pointer-ul la început.
    </simpara>
     &tip.ob-capture;
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = array ('a' => 'mãr', 'b' => 'parã', 'c' => array ('x','y','z'));
print_r($a);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Care va afiºa:
     <screen>
<![CDATA[
Array
(
    [a] => mãr
    [b] => parã
    [c] => Array
        (
            [0] => x
            [1] => y
            [2] => z
        )
)
]]>
      </screen>
     </para>
    <note>
     <simpara>
      La versiunile mai mici decât PHP 4.0.4, <function>print_r</function>
      va rula la infinit dacã se paseazã un <type>array</type> sau un
      <type>object</type> care conþine o referinþã directã la el însuºi.
      Un exemplu este <literal>print_r($GLOBALS)</literal> deoarece
      <literal>$GLOBALS</literal> este o variabilã globalã,
      care conþine o referinþã la ea insãºi.
     </simpara>
    </note>
    <simpara>
      Mai consultaþi <function>ob_start</function>, <function>var_dump</function>,
      ºi <function>var_export</function>.
    </simpara>

   </refsect1>
  </refentry>

  <refentry id="function.serialize">
   <refnamediv>
    <refname>serialize</refname>
    <refpurpose>
     Genereazã o reprezentare liniarã a unei variabile
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>string</type><methodname>serialize</methodname>
      <methodparam><type>mixed</type><parameter>value</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     <function>serialize</function> returneazã un ºir de caractere care conþine
     reprezentarea liniarã a parametrului <parameter>value</parameter>, care
     poate fi stocatã uºor sub aceastã formã.
    </simpara>
    <simpara>
     Este utilã pentru a stoca sau pentru a transmite variabile PHP
     fãrã alterarea tipului ºi structurii acestora.
    </simpara>
   <simpara>
    Pentru a reveni de la reprezentarea liniarã la cea a unei variabile PHP
    se foloseºte funcþia <function>unserialize</function>.
    <function>serialize</function> lucreazã cu toate tipurile de variabile,
    mai puþin cu tipul <type>resource</type>.
    Se poate folosi <function>serialize</function> chiar ºi pentru tablouri
    care conþin referinþe circulare (cãtre sine). Aceste referinþe
    vor fi ºi ele liniarizate ºi stocate.
   </simpara>
   <note>
    <para>
     În PHP 3, proprietãþile obiectelor sunt pãstrate, însã metodele
     se pierd. PHP 4 a eliminat aceastã limitare. Consultaþi ºi secþiunea
     <link linkend="language.oop.serialization">Liniarizarea obiectelor</link>
     a capitolului <link linkend="language.oop">Clase ºi
     obiecte</link> pentru mai multe informaþii.
    </para>
   </note>
    <para>
     <example>
      <title>Exemplu pentru funcþia <function>serialize</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// $session_data conþine un tablou multi-dimensional cu informaþii
// ale sesiunii pentru utilizatorul curent
// se foloseºte serialize() pentru a stoca acest tablou
// intr-o bazã de date la încheierea cererii

$conn = odbc_connect("webdb", "php", "chicken");
$stmt = odbc_prepare($conn,
            "UPDATE sessions SET data = ? WHERE id = ?");
$sqldata = array (serialize($session_data), $PHP_AUTH_USER);
if (!odbc_execute($stmt, &$sqldata)) {
    $stmt = odbc_prepare($conn,
                "INSERT INTO sessions (id, data) VALUES(?, ?)");
    if (!odbc_execute($stmt, &$sqldata)) {
    // ceva nu a funcþionat cum trebuie
    }
}
]]>
      </programlisting>
     </example>
    </para>
   <para>
    Mai consultaþi: <function>unserialize</function>.
   </para>
   </refsect1>
  </refentry>

  <refentry id="function.settype">
   <refnamediv>
    <refname>settype</refname>
    <refpurpose>Seteazã tipul unei variable</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>settype</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam><type>string</type><parameter>type</parameter></methodparam>
     </methodsynopsis>
    <para>
     Seteazã tipul <parameter>type</parameter> pentru variabila
     <parameter>var</parameter>.
    </para>
    <para>
     Valorile posibile pentru <parameter>type</parameter> sunt:
     <itemizedlist>
      <listitem>
       <simpara>
        "boolean" (sau, pânã la PHP 4.2.0, "bool")
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "integer" (sau, pânã la PHP 4.2.0, "int")
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "float" (disponibil începând cu PHP 4.2.0, pentru versiunile anterioare
        se foloseºte varianta învechitã "double")
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "string"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "array"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "object"
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        "null" (începând cu PHP 4.0.8)
       </simpara>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Returneazã &true; în cazul în care operaþia s-a executat cu succes,
     altfel returneazã &false;.
    </para>
    <para>
     <example>
      <title>Exemplu pentru funcþia <function>settype</function></title>
      <programlisting role="php">
<![CDATA[
<?php
$foo = "5bar"; // string
$bar = true;   // boolean

settype($foo, "integer"); // $foo este acum 5   (integer)
settype($bar, "string");  // $bar devine "1" (string)
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Mai consultaþi <function>gettype</function>,
     <link linkend="language.types.typecasting">Conversia tipurilor</link> ºi
     <link linkend="language.types.type-juggling">Tipuri de date</link>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.strval">
   <refnamediv>
    <refname>strval</refname>
    <refpurpose>Returneazã valoarea ca ºir de caractere a unei variabile</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>string</type><methodname>strval</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Returneazã valoarea ca ºir de caractere a parametrului <parameter>var</parameter>.
     Consultaþi documentaþia tipului <type>string</type> pentru mai multe informaþii
     legate de conversia la ºiruri de caractere.
    </simpara>
    <simpara>
     <parameter>var</parameter> poate fi orice tip scalar. Nu se poate folosi
     <function>strval</function> pentru tablouri ºi obiecte.
    </simpara>
    <simpara>
     Mai consultaþi <function>floatval</function>,
     <function>intval</function>, <function>settype</function> ºi
     <link linkend="language.types.type-juggling">Tipuri de date</link>.
    </simpara>
   </refsect1>
  </refentry>

  <refentry id="function.unserialize">
   <refnamediv>
    <refname>unserialize</refname>
    <refpurpose>
     Creeazã o variabilã PHP dintr-o reprezentare liniarã
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>mixed</type><methodname>unserialize</methodname>
      <methodparam><type>string</type><parameter>str</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     <function>unserialize</function> primeºte ca parametru o singurã variabilã
     liniarizatã (vezi <function>serialize</function>) ºi o converteºte
     "înapoi" într-o variabilã PHP. Este returnatã valoarea convertitã, care poate 
     sã aibã tipurile <type>integer</type>, <type>float</type>,
     <type>string</type>, <type>array</type> sau <type>object</type>.
    </simpara>
    <note>
     <para>
      Este posibilã setarea unei funcþii callback ce va fi apelatã
      dacã o clasã nedefinitã trebuie instanþiatã în timpul conversiei din
      forma liniarã (pentru a preveni preluarea incompletã a unui <type>object</type>).
      Se poate folosi &php.ini;, <function>ini_set</function> sau un fisier .htaccess
      pentru a defini 'unserialize_callback_func'.
      De câte ori o clasã trebuie instanþiatã, se va apela aceastã funcþie.
      Pentru a dezactiva aceastã facilitate, trebuie doar sã ºtergeþi aceastã
      setare.
     </para>
    </note>
    <para>
     <example>
      <title>Exemplu unserialize_callback_func</title>
      <programlisting role="php">
<![CDATA[
<?php
$serialized_object='O:1:"a":1:{s:7:"valoare";s:3:"100";}';

ini_set('unserialize_callback_func','mycallback'); // seteazã callback_function

function mycallback($classname) {
    // includeþi fiºierul care conþine definiþia clasei
    // se foloseºte $classname pentru a decide ce definiþie de clasã este vizatã
}
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      În PHP 3, metodele nu sunt pãstrate când se foloseºte unserialize pentru un obiect.
      PHP 4 eliminã aceastã limitare ºi restaureazã stât proprietãþile cât ºi metodele.
      Consultaþi secþiunea <link linkend="language.oop.serialization">Serializarea
      obiectelor</link> a capitolului <link linkend="language.oop">Clase ºi obiecte</link>
      pentru mai multe informaþii.
     </para>
    </note>
    <para>
     <example>
      <title>Exemplu pentru <function>unserialize</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// Aici se foloseºte unserialize() pentru a încãrca datele unei sesiuni
// în $session_data dintr-un string selectat dintr-o bazã de date.
// Acest exemplu este complementar celui pentru funcþia
// serialize.

$conn = odbc_connect ("webdb", "php", "chicken");
$stmt = odbc_prepare ($conn, "SELECT data FROM sessions WHERE id = ?");
$sqldata = array ($PHP_AUTH_USER);
if (!odbc_execute ($stmt, &$sqldata) || !odbc_fetch_into ($stmt, &$tmp)) {
    // se iniþializeazã cu tablou vid în cazul in care execute sau fetch nu funcþioneazã
    $session_data = array();
} else {
    // acum datele liniarizate sunt în $tmp[0].
    $session_data = unserialize ($tmp[0]);
    if (!is_array ($session_data)) {
    // dacã ceva nu merge cum trebuie, se iniþializeazã cu tablou vid
    $session_data = array();
    }
}
?>
]]>
      </programlisting>
     </example>
    </para>
   <para>
    Mai consultaþi: <function>serialize</function>.
   </para>
   </refsect1>
  </refentry>

  <refentry id="function.unset">
   <refnamediv>
    <refname>unset</refname>
    <refpurpose>ªterge variabilele date</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>void</type><methodname>unset</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><parameter>...</parameter></methodparam>
     </methodsynopsis>
    <note> 
       <para> 
        <function>unset</function> este o construcþie de limbaj. 
       </para> 
      </note> 
    <para>
     <function>unset</function> distruge variabilele specificate. de notat cã în PHP 3,
     <function>unset</function> returneazã întotdeauna &true;
     (de fapt valoarea întreagã 1). În PHP 4, 
     <function>unset</function> nu mai este o funcþie, ci o instrucþiune.
     De aceea, încercarea de a atribui unei variabile valoarea returnatã de 
     <function>unset</function> se va solda cu eroare gramaticalã (parse error).
    </para>
    <para>
     <example>
      <title>Exemplu pentru <function>unset</function></title>
      <programlisting role="php">
<![CDATA[
<?php
// distruge o singurã variabilã
unset ($foo);

// distruge un singur element al unui tablou
unset ($bar['quux']);

// distruge mai multe variabile
unset ($foo1, $foo2, $foo3);
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     Comportamentul <function>unset</function> în interiorul unei funcþii
     poate sã varieze în funcþie de ce anume se doreºte a fi distrus.
    </para>
    <para>
     Dacã se aplicã <function>unset</function> pe o variabilã globalã
     în interiorul unei funcþii, doar variabila localã va fi ºtearsã.
     Valoarea variabilei globale va fi aceeaºi dupã ce iese din mediul
     funcþiei.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function destroy_foo() {
    global $foo;
    unset($foo);
}

$foo = 'bar';
destroy_foo();
echo $foo;
?>
]]>
      </programlisting>
     </informalexample>
     Exemplul de mai sus va afiºa:
     <informalexample>
      <screen>
<![CDATA[
bar
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     De asemenea, ºi dacã o variabilã este transmisã prin referinþã,
     va fi distrusã doar variabila din interiorul funcþiei.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function foo(&$bar) {
    unset($bar);
    $bar = "blah";
}

$bar = 'something';
echo "$bar\n";

foo($bar);
echo "$bar\n";
?>
]]>
      </programlisting>
     </informalexample>
     Exemplul de mai sus va afiºa:
     <informalexample>
      <screen>
<![CDATA[
something
something
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Dacã o variabilã staticã este distrusã în interiorul unei funcþii,
     vor fi distruse toate variabilele ºi referinþele lor.
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function foo() {
    static $a;
    $a++;
    echo "$a\n";

    unset($a);
}

foo();
foo();
foo();
?>
]]>
      </programlisting>
     </informalexample>
     Exemplul de mai sus va afiºa:
     <informalexample>
      <screen>
<![CDATA[
1
2
3
]]>
      </screen>
     </informalexample>
    </para>
    <para>
     Dacã doriþi sã distrugeþi o variabilã globalã în interiorul unei funcþii,
     puteþi folosi tabloul <parameter>$GLOBALS</parameter>:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
function foo() {
    unset($GLOBALS['bar']);
}

$bar = "something";
foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     Mai consultaþi <function>isset</function> ºi
     <function>empty</function>.
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.var-dump">
   <refnamediv>
    <refname>var_dump</refname>
    <refpurpose>Afiºeazã informaþii despre o variabilã</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>void</type><methodname>var_dump</methodname>
      <methodparam><type>mixed</type><parameter>expression</parameter></methodparam>
      <methodparam choice="opt"><type>mixed</type><parameter>expression</parameter></methodparam>
      <methodparam choice="opt"><parameter>...</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Aceastã funcþie afiºeazã o informaþie structuratã despre una sau mai multe
     variabile. Tablourile sunt explorate recursiv pentru a afiºa valorile
     în aceastã structurã.
    </simpara>
    &tip.ob-capture;
    <simpara>
     Comparaþi <function>var_dump</function> cu
     <function>print_r</function>.
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = array (1, 2, array ("a", "b", "c"));
var_dump ($a);

/* afiºeazã:
array(3) {
  [0]=>
  int(1)
  [1]=>
  int(2)
  [2]=>
  array(3) {
    [0]=>
    string(1) "a"
    [1]=>
    string(1) "b"
    [2]=>
    string(1) "c"
  }
}

*/

$b = 3.1;
$c = TRUE;
var_dump($b,$c);

/* afiºeazã:
float(3.1)
bool(true)

*/
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </refsect1>
  </refentry>


  <refentry id="function.var-export">
   <refnamediv>
    <refname>var_export</refname>
    <refpurpose>Afiºeazã o reprezentare ca ºir de caractere a unei variabile</refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>mixed</type><methodname>var_export</methodname>
      <methodparam><type>mixed</type><parameter>expression</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>return</parameter></methodparam>
     </methodsynopsis>
    <simpara>
     Aceastã funcþie returneazã o informaþie structuratã despre o variabilã.
     Este similarã funcþiei <function>var_dump</function>, cu excepþia faptului
     cã reprezentarea returnatã este un cod PHP valid.
    </simpara>
    <simpara>
     Dacã se foloseºte cel de-al doilea parametru optional cu valoarea &true;
     se poate returna aceastã reprezentare pentru a fi atribuitã unei variabile.
    </simpara>
    <simpara>
     Comparaþi <function>var_export</function> cu
     <function>var_dump</function>.
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$a = array (1, 2, array ("a", "b", "c"));
var_export ($a);

/* afiºeazã:
array (
  0 => 1,
  1 => 2,
  2 => 
  array (
    0 => 'a',
    1 => 'b',
    2 => 'c',
  ),
)
*/

$b = 3.1;
$v = var_export($b, TRUE);
echo $v;

/* afiºeazã:
3.1
*/
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </refsect1>
  </refentry>

  <refentry id="function.is-callable">
   <refnamediv>
    <refname>is_callable</refname>
    <refpurpose>
     Decide dacã argumentul este o construcþie apelabilã
    </refpurpose>
   </refnamediv>
   <refsect1>
    <title>Descriere</title>
     <methodsynopsis>
      <type>bool</type><methodname>is_callable</methodname>
      <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
      <methodparam choice="opt"><type>bool</type><parameter>syntax_only</parameter></methodparam>
      <methodparam choice="opt"><type>string</type><parameter>callable_name</parameter></methodparam>
     </methodsynopsis>
    <para>
     &warn.undocumented.func;
    </para>
   </refsect1>
  </refentry>
  

 </reference>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->

