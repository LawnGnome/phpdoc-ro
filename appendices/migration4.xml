<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.41 Maintainer: simionea Status: translated -->
 <appendix xml:id="migration4" xmlns="http://docbook.org/ns/docbook">
  <title>Migrarea de la PHP 3 la PHP 4</title>

  <section xml:id='migration4.changes'>
   <title>Ce s-a schimbat în PHP 4</title>
   <para>
    PHP 4 şi motorul integrat Zend au îmbunătăţit substanţial performanţa şi
    capacităţile PHP, dar o mare atenţie s-a acordat faptului de a deteriora
    cât mai puţin posibil codul-sursă existent. Deci migrarea codului dumneavoastră
    de la PHP 3 la 4 ar trebui să fie mult mai uşoară decât migrarea de la PHP/FI 2
    la PHP 3. O bună parte din codul-sursă existent în PHP 3 ar trebui să fie gata
    de a rula fără schimbări, dar totuşi ar trebui să ştiţi despre puţinele diferenţe
    şi să aveţi grijă să testaţi codul dumneavoastră sursă înainte de a schimba
    versiunile în mediile de producere. Următoarele ar trebui să vă dea nişte idei
    unde şi ce să căutaţi.
   </para>
  </section>

  <section xml:id="migration4.php4.with.php3">
   <title>Rularea concomitentă a PHP 3 şi PHP 4</title>
   <simpara>
    Sistemele de operare recente oferă posibilitatea de a efectua separarea pe versiuni
    şi domenii. Aceste facilităţi fac posibilă rularea concomitentă a PHP 3 şi PHP 4
    în calitate de module pe acelaşi server Apache.
   </simpara>
   <simpara>
    Această facilitate funcţionează pe următoarele platforme: 
   </simpara>
   <itemizedlist>
     <listitem><simpara>Linux cu binutils recent (testat cu binutils 2.9.1.0.25)</simpara></listitem>
     <listitem><simpara>Solaris 2.5 sau mai bun</simpara></listitem>
     <listitem><simpara>FreeBSD (testat cu 3.2, 4.0)</simpara></listitem>
   </itemizedlist>
   <para>
    Pentru a o activa, configuraţi PHP 3 şi PHP 4 să utilizeze APXS
    (<option role="configure">--with-apxs</option>) şi extensiile de legătură necesare
    (<option role="configure">--enable-versioning</option>).
    În rest, toate instrucţiunile standarde de instalare rămân în vigoare. Spre exemplu:
    <informalexample>
     <programlisting role="shell">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
     </programlisting>
    </informalexample>
   </para>
  </section>

  <section xml:id="migration4.configuration">
   <title>Migrarea fişierelor de configurare</title>
   <para>
    Fişierul de configurare global, <filename>php3.ini</filename>,
    şi-a schimbat numele în &php.ini;.
   </para>
   <para>
    Pentru fişierul de configurare Apache sunt un pic mai multe schimbări.
    Tipurile MIME recunoscute de modulul PHP s-au schimbat.
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Puteţi face ca fişierele de configurare să funcţioneze cu ambele versiuni
    ale PHP (în dependenţă de ce versiune este la moment compilată în server)
    utilizând următoarea sintaxă:
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    În plus, denumirile directivelor PHP pentru Apache s-au schimbat.
   </simpara>
   <para>
    Începând cu PHP 4.0, există doar patru directive Apache ce se referă la PHP:
    <informalexample>
     <programlisting role="apache-conf">
<![CDATA[
php_value [denumirea directivei PHP] [valoarea]
php_flag [denumirea directivei PHP] [On|Off]
php_admin_value [denumirea directivei PHP] [valoarea]
php_admin_flag [denumirea directivei PHP] [On|Off]
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Sunt două diferenţe între valorile 'Admin' şi cele 'non Admin':
   </simpara>
   <itemizedlist>
    <listitem>
     <simpara>
      Valorile (sau fanioanele) 'Admin' pot să apară doar în fişierele de configurare Apache
      ce se referă la întreg serverul (de ex. &httpd.conf;).
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Valorile (sau fanioanele) standarde nu pot controla unele directive PHP, de exemplu: 
      &safemode; (dacă aţi fi putut schimba configurarea modului securizat în fişierele
      &htaccess;, aceasta ar fi anulat scopul &safemode;). În contrast, valorile 'Admin' pot
      modifica valoarea oricărei directive PHP.
     </simpara>
    </listitem>
   </itemizedlist>
   <simpara>
    Pentru a face procesul de tranziţie mai simplu, PHP 4 conţine script-uri care
    convertesc automat fişierele de configurare Apache şi &htaccess; să lucreze
    atât cu PHP 3, cât şi cu PHP 4. Aceste script-uri NU convertesc liniile cu
    tipurile MIME! Dumneavoastră trebuie să le convertiţi în mod manual.
   </simpara>
   <para>
    Pentru a converti fişierele de configurare Apache, lansaţi script-ul
    apconf-conv.sh (disponibil în directorul scripts/apache/). De exemplu:
    <informalexample>
     <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Fişierul de configuraţie original va fi salvat în httpd.conf.orig.
   </simpara>
   <para>
    Pentru a converti fişierele &htaccess;, lansaţi script-ul
    <filename>aphtaccess-conv.sh</filename> (disponibil de asemenea în directorul
    <filename>scripts/apache/</filename>):
    <informalexample>
     <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Similar, fişierele vechi &htaccess; vor fi salvate cu terminaţia '.orig'.
   </simpara>
   <simpara>
    Script-urile de conversie necesită ca 'awk' să fie instalat.
   </simpara>
  </section>

  <section xml:id='migration4.parser'>
   <title>Comportamentul analizatorului</title>
   <para>
    Analiza şi execuţia sunt acum doi paşi separaţi, nici o execuţie a
    codului-sursă din fişier nu va avea loc până când întregul fişier şi
    toate fişierele pe care le necesită nu au fost analizate deplin şi cu
    succes.
   </para>
   <para>
    Una din cerinţele noi introduse de către această separare este aceea
    că fişierele necesare şi cele incluse acum trebuie să fie depline din
    punct de vedere sintactic. Nu mai puteţi împrăştia diferite părţi ale
    unei structuri de control în mai multe fişiere. Adică nu puteţi începe
    o buclă <literal>for</literal> sau <literal>while</literal>, un control
    <literal>if</literal> sau un bloc <literal>switch</literal> într-un
    fişier şi să aveţi sfârşitul buclei, declaraţiile <literal>else</literal>,
    <literal>endif</literal>, <literal>case</literal> sau
    <literal>break</literal> în alt fişier.
   </para>
   <para>
    Totuşi este perfect legitim de a include cod-sursă suplimentar în cadrul
    buclelor, sau a altor structuri de control, doar că cuvintele cheie de control
    şi parantezele ondulate corespunzătoare <literal>{...}</literal> trebuie
    să fie în cadrul aceleiaşi unităţi compilate (fişier sau string
    <function>eval</function>-uat).
   </para>
   <para>
    Aceasta nu ar trebui să dăuneze prea mult, deoarece o astfel de împrăştiere a
    codului-sursă oricum trebuie considerată ca un stil de scriere foarte rău.
   </para>
   <para>
    Un alt lucru care nu mai este posibil, însă rar întâlnit în coduri PHP 3
    este întoarcerea valorilor dintr-un fişier necesar, apelat prin
    <function>require</function>. Întoarcerea unei valori dintr-un fişier
    inclus încă este posibilă.
   </para>
  </section>

  <section xml:id='migration4.error-reporting'>
   <title>Raportarea erorilor</title>

   <section xml:id='migration4.error-reporting.config'>
    <title>Schimbările în configurare</title>
    <para>
     În PHP 3 nivelul raportării erorilor era stabilit ca o simplă
     valoare numerică formată prin sumarea numerelor referitoare la
     diferite nivele ale erorilor. Valorile obişnuite erau 15 pentru
     raportarea tuturor erorilor şi avertizărilor sau 7 pentru raportarea
     a tot, în afară de mesajele simple de notificare referitoare la
     stilul nepotrivit sau alte lucruri de acest fel.
    </para>
    <para>
     PHP 4 are un set mai mare de nivele de erori şi avertizări şi vine cu
     un analizator al configuraţiei care acum permite utilizarea constantelor
     simbolice pentru stabilirea comportamentului intenţionat.
    </para>
    <para>
     Nivelul raportării erorilor trebuie acum configurat eliminând în mod
     explicit nivelele de avertizări care nu doriţi să genereze mesaje de
     erori cu ajutorul operaţiei XOR din constanta simbolică
     <literal>E_ALL</literal>. Sună complicat? Ei bine, să zicem că doriţi
     ca sistemul de raportare a erorilor să raporteze totul în afară de
     avertizările simple de stil care sunt categorizate de constanta simbolică
     <literal>E_NOTICE</literal>. Atunci veţi scrie următoarele în fişierul
     &php.ini;: <literal>error_reporting = E_ALL &amp; ~ ( E_NOTICE )</literal>.
     Dacă de asemenea doriţi să suprimaţi avertizările, trebuie să adăugaţi
     constanta corespunzătoare în paranteze utilizând operatorul binar '|':
     <literal>error_reporting= E_ALL &amp; ~ ( E_NOTICE | E_WARNING )</literal>.
    </para>
    <warning>
     <para>
      La reînnoirea codului-sursă, sau a serverelor de la PHP 3 la PHP 4 ar
      trebui să verificaţi aceste setări şi apeluri către
      <function>error_reporting</function>, sau aţi putea să dezactivaţi
      raportarea erorilor de tipuri noi, în special
      <literal>E_COMPILE_ERROR</literal>. Aceasta poate duce la obţinerea unui
      rezultat vid, fără vre-un indiciu despre ce s-a întâmplat sau unde de
      căutat problema.
     </para>
    </warning>
    <warning>
     <para>
      Utilizatea valorilor vechi 7 şi 15 pentru a stabili nivelul raportării
      erorilor este o ideie foarte rea, deoarece aceasta va suprima unele clase
      noi de erori, inclusiv erori la analiză. Aceasta poate rezulta într-un
      comportament foarte ciudat, deoarece script-urile pot să nu mai funcţioneze,
      fără a afişa erori undeva.
     </para>
     <para>
      Aceasta a condus în trecut la o mulţime de rapoarte de erori nereproductibile
      când persoanele se ciocneau de probleme ale motorului de scriptare, pe care
      nu le puteau depista, în timp ce în realitate eroarea era o acoladă '}' care
      lipsea într-un fişier necesar, eroare pe care analizatorul nu era în stare să
      o raporteze din cauza sistemului de raportare a erorilor configurat greşit.
     </para>
     <para>
      Deci verificarea parametrilor raportării erorilor ar trebui să fie primul lucru
      pe care trebuie să-l faceţi atunci când script-urile dumneavoastră mor în tăcere.
      Motorul Zend poate fi considerat suficient de matur în zilele noastre
      pentru a nu cauza un astfel de comportament ciudat.
     </para>
    </warning>
   </section>

   <section xml:id='migration4.error-reporting.additions'>
    <title>Mesaje de avertizare suplimentare</title>
    <para>
     Foarte mult cod-sursă PHP 3 existent utilizaeză construcţii de limbaj
     care ar trebui considerate de stil foarte prost, deoarece acest cod,
     făcând în prezent ceea ce era intenţionat, ar putea fi foarte uşor
     stricat de schimbări din alte locuri. PHP 4 va afişa o mulţime de
     mesaje de notificare în astfel de situaţii când PHP 3 nu le-ar fi
     afişat. Soluţia cea mai simplă este de a deconecta pur şi simplu
     mesajele <literal>E_NOTICE</literal>, însă mai bine ar fi de a corecta
     codul-sursă în loc.
    </para>
    <para>
     Cel mai frecvent caz care acum va produce notificări este utilizarea
     constantelor string fără ghilimele în calitate de indici ai masivului.
     Atât PHP 3 cât şi 4 vor interpreta acestea ca string-uri dacă nu este
     vre-un cuvânt-cheie cau vre-o constantă cu acest nume, însă dacă o
     constantă cu un astfel de nume a fost definită anterior, aceasta ar
     putea deteriora script-ul dumneavoastră. Aceasta chiar poate deveni un
     risc de securitate dacă un intrus reuşeşte să redefinească constantele
     string în aşa fel, încât script-ul să-i ofere drepturi de acces, pe
     care nu trebuia să le aibă. De accea PHP 4 acum vă va avertiza de fiecare
     dată când utilizaţi constante string fără ghilimele, cum ar fi spre
     exemplu <literal>$_SERVER[REQUEST_METHOD]</literal>. Schimbând aceasta în
     <literal>$_SERVER['REQUEST_METHOD']</literal> va face analizatorul mai
     fericit şi va îmbunătăţi substanţial stilul şi securitatea codului
     dumneavoastră.
    </para>
    <para>
     Un alt lucru despre care PHP 4 vă va spune acum este utilizarea variabilelor
     sau a elementelor de masiv neiniţializate.
    </para>
   </section>
   
  </section>

  <section xml:id='migration4.initializers'>
   <title>Iniţializatorii</title>
   <para>
    Iniţializatorii variabilelor statice şi a membrilor clasei acceptă numai valori
    scalare, în timp ce în PHP 3 ei acceptau orice expresie validă. Aceasta se
    datorează, iarăşi, separării dintre analiză şi execuţie deoarece nici un
    cod-sursă încă nu a fost executat când analizatorul vede iniţializatorul.
   </para>
   <para>
    Pentru clase ar trebui să utilizaţi în loc constructori pentru a iniţializa
    variabilele membre. Pentru variabilele statice ceva diferit de o simplă
    valoare statică rareori are sens.
   </para>
  </section>

  <section xml:id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
    Posibil cea mai controversată schimbare în comportament a survenit în funcţia
    <function>empty</function>. Un String conţinând doar caracterul '0' (zero)
    este acum considerat vid, în timp ce în PHP 3 nu era considerat ca atare.
   </para>
   <para> 
    Acest comportament nou are sens în aplicaţiile web, unde toate câmpurile de
    introducere întorc string-uri chiar dacă se cere introducerea unui număr, iar
    PHP are capacitatea de convertire automată a tipurilor. Însă pe de altă parte
    aceasta poate deteriora codul-sursă al dumneavoastră într-un mod oarecum subtil,
    ce va conduce la un comportament greşit, dificil de depistat dacă nu cunoaşteţi
    ce şi unde trebuie să căutaţi.
   </para>
  </section>

  <section xml:id='migration4.missing'>
   <title>Funcţii care lipsesc</title>
   <para>
    În timp ce PHP 4 vine cu o mulţime de facilităţi noi, funcţii şi extensii,
    puteţi încă să descoperiţi că lipsesc unele funcţii din versiunea 3. Un mic
    număr de funcţii de bază au dispărut deoarece ele nu funcţionau cu noua schemă
    de separare a analizei şi a execuţiei, introdusă în PHP 4 cu motorul Zend. Alte
    funcţii şi chiar extensii întregi au devenit învechite, odată ce funcţii şi
    extensii noi efectuează aceleaşi sarcini mai bine şi/sau într-un mod mai general.
    Unele funcţii pur şi simplu nu au fost încă transferate şi în sfârşit unele
    funcţii sau extensii pot să lipsească din cauza conflictelor de licenţiere.
   </para>

   <section xml:id='migration4.missing.concept'>
    <title>Funcţii care lipsesc din cauza modificărilor conceptuale</title>
    <para>
     Deoarece PHP 4 acum separă analiza de execuţie, nu mai este posibil de a modifica
     comportamentul analizatorului (acum încorporat în motorul Zend) în timpul rulării
     deoarece analiza a avut loc deja. Deci funcţia <function>short_tags</function>
     nu mai există. Puteţi modifica comportamentul analizatorului stabilind valorile
     potrivite în fişierul &php.ini;.
    </para>
    <para>
     O altă facilitate a PHP 3 care nu mai face parte din PHP 4 este interfaţa de
     debugging încorporată. Există module suplimentare (add-on) ale părţilor terţe
     pentru motorul Zend care oferă o funcţionalitate similară.
    </para>
   </section>

   <section xml:id='migration4.deprecate'>
    <title>Funcţii şi extensii învechite</title>
    <para>
     Extensiile pentru baze de date Adabas şi Solid nu mai sunt. Trăiască extensia
     unificată ODBC în loc.
    </para>
   </section>

   <section xml:id='migration4.unset'>
    <title>Schimbarea statutului <function>unset</function></title>
    <para>
     <function>unset</function>, fiind încă disponibilă, este implementată în calitate de
     construcţie a limbajului, dar nu ca funcţie.
    </para>
    <para>
     Aceasta nu are vre-o consecinţă asupra comportamentului <function>unset</function>,
     dar testarea "unset" utilizând <function>function_exists</function> va întoarce
     &false; ca şi cu orice altă construcţie a limbajului care seamănă cu o funcţie,
     cum ar fi <function>echo</function>.
    </para>
    <para>
     O altă schimbare mai practică constă în aceea că nu mai este posibil de a apela
     <function>unset</function> indirect, adică
     <literal>$func="unset"; $func($somevar)</literal> nu va mai funcţiona.
    </para>
   </section>
  </section>

  <section xml:id='migration4.extensions'>
   <title>Extensiile PHP 3</title>
   <para>
    Extensiile scrise pentru PHP 3 nu vor funcţiona cu PHP 4, nici ca binare, nici
    la nivelul codului-sursă. Nu este dificil de a transfera extensiile în PHP 4
    dacă aveţi acces la sursele originale. O descriere detaliată a procesului de
    transfer nu este în scopul acestui text.
   </para>
  </section>

  <section xml:id='migration4.strings'>
   <title>Substituirea variabilelor în string-uri</title>
   <para>
    PHP 4 introduce un mecanism nou de substituire a variabilelor în string-uri.
    Acum, în sfârşit, puteţi accesa variabilele membre ale obiectelor şi elemente
    ale masivelor multidimensionale din string-uri.
   </para>
   <para>
    Pentru a realiza aceasta trebuie să cuprindeţi variabilele între acolade ondulate,
    cu semnul dolarului urmând imediat după deschiderea acoladei:
    <literal>{$...}</literal>
   </para>
   <para>
    Pentru a încorpora valoarea unei variabile membre a unui obiect într-un string
    pur şi simplu scrieţi <literal>"text {$obj-&gt;member} text"</literal>, în timp
    ce în PHP 3 trebuia să utilizaţi ceva de tipul
    <literal>"text".$obj-&gt;member." text"</literal>.
   </para>
   <para>
    Aceasta ar trebui să conducă la un cod-sursă mai lizibil, în timp ce poate
    deteriora script-urile existente scrise pentru PHP 3. Dar puteţi cu uşurinţă
    să verificaţi existenţa acestei probleme căutând combinaţia de caractere
    <literal>{$</literal> în codul-sursă şi înlocuind-o cu
    <literal>\{$</literal> cu ajutorul instrumentului dumneavoastră preferat
    de căutare şi înlocuire.
   </para>
  </section>

  <section xml:id='migration4.cookies'>
   <title>Prăjiturile (cookies)</title>
   <para>
    PHP 3 avea obiceiul prost de a stabili prăjiturile în ordine inversă a
    apelurilor <function>setcookie</function> din codul-sursă. PHP 4 întrerupe
    acest obicei şi crează liniile de antet cu prăjiturile exact în aceeaşi ordine
    în care stabiliţi prăjiturile în codul-sursă.
   </para>
   <para>
    Aceasta poate să deterioreze careva cod-sursă existent, dar comportamentul
    vechi era într-atât de straniu, încât a meritat să fie schimbat pentru a
    preveni alte probleme în viitor.
   </para>
  </section>

  <section xml:id='migration4.variables'>
   <title>Manipularea variabilelor globale</title>
   <para>
    În timp ce manipularea variabilelor globale avea ca scop simplitatea în PHP 3
    şi în versiunile timpurii ale PHP 4, acum accentul a fost pus pe sporirea securităţii.
    În timp ce în PHP 3 următorul exemplu funcţiona perfect, în PHP 4 variabila
    trebuie desetată (<literal>unset($GLOBALS["id"])</literal>);. Aceasta este doar
    o problemă cu manipularea variabilelor globale. Întotdeauna ar fi trebuit să
    utilizaţi <varname>$GLOBALS</varname>, cu versiunile mai noi ale PHP 4
    dumneavoastră sunteţi forţat să faceţi aşa în majoritatea cazurilor.
    Citiţi mai multe despre acest subiect în <link linkend="references.global">
    secţiunea de referinţă <literal>global</literal></link>.
   </para>
   <example>
    <title>Migrarea variabilelor globale</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function test()
{
    global $id;
    unset($id);
}
test();
echo($id); // Aceasta va afişa 1 în PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>

<!-- Translated by Simion Onea -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
