<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.1 $ -->
<!-- EN-Revision: 1.27 Maintainer: simionea Status: translated -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>Migrarea de la PHP/FI 2 la PHP 3</title>

 <section xml:id="migration.about">
  <title>Despre incompatibilităţile din 3.0</title>

  <simpara>
   PHP 3.0 este rescris de la zero. El posedă un analizator potrivit
   care este mult mai robust şi mai consistent decât cel din 2.0. 3.0
   este de asemenea mult mai rapid şi utilizează mai puţină memorie.
   Însă unele din aceste îmbunătăţiri nu au fost posibile fără schimbări
   în compatibilitate, atât în sintaxă, cât şi în funcţionalitate.
  </simpara>

  <simpara>
   Suplimentar, programatorii PHP au încercat să curăţe atât sintaxa PHP,
   cât şi semantica sa în versiunea 3.0, şi aceasta la fel a cauzat unele
   incompatibilităţi. La scară largă, noi considerăm că aceste schimbări
   sunt spre bine.
  </simpara>

  <simpara>
   Acest capitol va încerca să vă indice calea prin incompatibilităţile
   de care vă puteţi ciocni la trecerea de la PHP/FI 2.0 la PHP 3.0 şi să
   vă ajute să le depăşiţi. Facilităţile noi nu sunt menţionate aici, dacă
   aceasta nu este necesar.
  </simpara>

  <simpara>
   Există şi un program de convertire, care poate converti automat script-urile
   dumneavoastră vechi PHP/FI 2.0. El poate fi găsit în subdirectorul
   <filename class="directory">convertor</filename> al distributivului PHP 3.0.
   Însă acest program interceptează doar schimbările de sintaxă, de aceea
   oricum trebuie să citiţi cu atenţie acest capitol.
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   Declaraţia <literal>old_function</literal> vă permite să declaraţi
   o funcţie utilizând o sintaxă identică cu PHP/FI2 (cu excepţia că trebuie
   să înlocuiţi 'function' cu 'old_function').
  </simpara>
  <simpara>
   Aceasta este o facilitate dezaprobată şi ar trebui utilizată numai de convertorul
   PHP/FI2-&gt;PHP 3.
  </simpara>
  <warning>
   <para>
    Funcţiile declarate ca <literal>old_function</literal> nu pot fi apelate din
    codul-sursă intern al PHP. Printre altele, aceasta înseamnă că nu le puteţi
    utiliza în funcţii ca <function>usort</function>, <function>array_walk</function>
    şi <function>register_shutdown_function</function>. Puteţi să depăşiţi această
    limitare scriind o funcţie-înveliş (în forma normală PHP 3) care să apeleze
    <literal>old_function</literal>.
   </para>
  </warning>
 </section>
 
 <section xml:id="migration.startendtags">
  <title>Etichetele de start/sfârşit</title>

  <para>
   Primul lucru pe care probabil îl veţi observa este că etichetele de start şi de
   sfârşit ale PHP s-au schimbat. Forma veche <literal>&lt;? &gt;</literal> a fost înlocuită
   de alte trei forme noi posibile:
   <example>
    <title>Migrarea: etichetele de start/sfârşit vechi</title>
    <programlisting role="php">
<![CDATA[
<? echo "Acesta este cod PHP/FI 2.0.\n"; >
]]>
    </programlisting>
   </example>
   Începând cu versiunea 2.0, PHP/FI de asemenea susţine această variaţie:
   <example>
    <title>Migrarea: primele etichete de start/sfârşit</title>
    <programlisting role="php">
<![CDATA[
<? echo "Acesta este cod PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Observaţi că acum eticheta de sfârşit constă dintr-un semn de întrebare
   şi un caracter "mai mare ca" în loc de numai "mai mare ca". Însă dacă
   planificaţi să utilizaţi XML pe server, vă veţi ciocni de probleme
   utilizând prima variantă, deoarece PHP poate să încerce să execute
   marcajul XML din documentele XML ca cod PHP. Din această cauză a fost
   introdusă următoarea variaţie:

   <example>
    <title>Migrarea: a doua pereche nouă de etichete de start/sfârşit</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Acesta este cod PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Unele persoane au avut probleme cu editoare care nu înţeleg de loc etichetele
   instrucţiunilor pentru procesare. Microsoft FrontPage este un astfel de editor,
   şi pentru a depăşi aceste probleme, următoarea variaţie a fost introdusă:

   <example>
    <title>Migrarea: a treia pereche nouă de etichete de start/sfârşit</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Acesta este cod PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>Sintaxa if..endif</title>

  <para>
   Modul 'alternativ' pentru a scrie declaraţiile if/elseif/else, utilizând if();
   elseif(); else; endif; nu pot fi implementate eficient fără a introduce o mare
   complexitate în analizatorul 3.0. Din această cauză a fost schimbată sintaxa:
   <example>
    <title>Migrarea: sintaxa veche if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "yep\n";
elseif ($bar);
    echo "almost\n";
else;
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrarea: noua sintaxă if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "yep\n";
elseif ($bar):
    echo "almost\n";
else:
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>

   Observaţi că punctul şi virgula au fost înlocuite cu două puncte în toate
   declaraţiile în afară de cea care încheie expresia (endif).
  </para>
 </section>

 <section xml:id="migration.while">
  <title>Sintaxa while</title>
  <para>
   La fel ca şi în cazul if..endif, sintaxa while..endwhile de asemenea s-a schimbat:
   <example>
    <title>Migrarea: sintaxa veche while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrarea: sintaxa nouă while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Dacă utilizaţi sintaxa veche while..endwhile în PHP 3.0 veţi intra într-o
    buclă fără sfârşit.
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>Tipurile expresiilor</title>
  <simpara>
   PHP/FI 2.0 utiliza partea stângă a expresiilor pentru a determina
   de ce tip ar trebui să fie rezultatul. PHP 3.0 ia în consideraţie
   ambele părţi la determinarea tipurilor rezultatelor, şi aceasta poate
   duce la aceea că script-urile 2.0 se vor comporta imprevizibil în 3.0.
  </simpara>
  <para>
   Consideraţi urnătorul exemplu:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   În PHP/FI 2.0 aceasta va afişa ambii indici ai $a. În PHP 3.0
   aceasta nu va afişa nimic. Motivul este că în PHP 2.0 din cauza
   că tipul argumentului stâng era string, se efectua o comparaţie
   între string-uri, şi într-adevăr <literal>""</literal> nu este
   egal cu <literal>"0"</literal> şi ciclul rula. În PHP 3.0,
   când un string este comparat cu un integer, se efectuează o
   comparaţie între integeri (string-ul este convertit în integer).
   Aceasta rezultă în compararea <literal>atoi("")</literal>, care
   este <literal>0</literal> şi <literal>variablelist</literal>, care
   de asemenea e <literal>0</literal>, şi deoarece <literal>0==0</literal>,
   ciclul nu se execută nici o dată.
  </para>
  <para>
   Pentru a corecta acest exempu înlocuiţi declaraţia while cu:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>Mesajele de eroare s-au schimbat</title>
  <simpara>
   Mesajele de eroare ale PHP 3.0 sunt de obicei mai exacte decât cele din 2.0,
   însă de acum nu mai vedeţi fragmentul codului-sursă care a cauzat eroarea.
   Cu toate acestea, va fi furnizat numele fişierului şi numărul liniei unde
   s-a petrecut eroarea.
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>Evaluarea boolean-ă scurt-circuitată</title>
  <simpara>
   În PHP 3.0 evaluarea boolean-ă e scurt-circuitată. Aceasta înseamnă că într-o
   expresie ca <literal>(1 || test_me())</literal>, funcţia <function>test_me</function>
   nu va fi executată deoarece nimic nu poate schimba rezultatul expresiei după
   <literal>1</literal>.
  </simpara>

  <simpara>
   Aceasta este o problemă minoră de compatibilitate, dar poate cauza efecte secundare
   neprevăzute.
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>Valorile &true;/&false; întoarse de funcţii</title>
  <simpara>
   Majoritatea funcţiilor interne au fost rescrise pentru a întoarce &true; în
   caz de succes şi &false; în caz de eşec, contrar cu 0 şi -1 respectiv în PHP/FI 2.0.
   Noul comportament permite scrierea unui cod mai logic, cum ar fi
   <literal>$fp = fopen("/your/file") or fail("ahh!");</literal>. Deoarece PHP/FI 2.0
   nu avea reguli clare despre ce valori trebuie să întoarcă funcţiile când eşuează,
   majoritatea acestor script-uri probabil vor trebui verificate manual după utilizarea
   convertorului 2.0 în 3.0.
  </simpara>
  <para>
   <example>
    <title>Migrarea de la 2.0: valoarea întoarsă, codul vechi</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Nu a putut fi deschis $file pentru citire<br />\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migrarea de la 2.0: valoarea întoarsă, codul nou</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Nu a putut fi deschis $file pentru citire<br />\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.other">
  <title>Alte incompatibilităţi</title>

  <itemizedlist>
   <listitem><simpara>
    Modulul Apache pentru PHP 3.0 nu mai susţine Apache de versiuni mai vechi decât 1.2.
    Apache 1.2 sau ulterior este necesar.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> nu mai susţine string de formatare.
    În loc, utilizaţi funcţia <function>printf</function>.
   </simpara></listitem>

   <listitem><simpara>
    În PHP/FI 2.0 un efect secundar de implementare cauza <literal>$foo[0]</literal>
    să aibă acelaşi efect ca şi <literal>$foo</literal>. Aceasta nu este adevărat pentru PHP 3.0.
   </simpara></listitem>

   <listitem>
    <simpara>
     Citirea masivelor cu <literal>$array[]</literal> nu mai este susţinută
    </simpara>
    <simpara>
     Adică nu puteţi traversa un masiv având un ciclu cu
     <literal>$data = $array[]</literal>. Utilizaţi <function>current</function>
     şi <function>next</function> în loc.
    </simpara>
    <simpara>
     De asemenea, <literal>$array1[] = $array2</literal> nu adaugă valorile din
     <literal>$array2</literal> la <literal>$array1</literal>, dar adaugă
     <literal>$array2</literal> în calitate de ultimă înregistrare în
     <literal>$array1</literal>. Vedeţi de asemenea susţinerea masivelor multidimensionale.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> nu mai este utilizat în calitate de operator de concatenare
     a string-urilor; el converteşte argumentele sale în numere şi efectuează
     sumarea numerică. Utilizaţi <literal>"."</literal> în loc.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migrarea de la 2.0: concatenarea string-urilor</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    În PHP 2.0 aceasta ar afişa 11, în PHP 3.0 aceasta ar afişa 2. În loc, utilizaţi:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Aceasta va afişa 2 în ambele PHP 2.0 şi 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Aceasta va afişa 11 în PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Translated by Simion Onea -->

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
